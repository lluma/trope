{"version":3,"sources":["Component/AnnoPaper.js","Component/CorpusList.js","App.js","serviceWorker.js","index.js"],"names":["data","result","handleClosePaperFunc","handleSaveResultFunc","inputRef","useRef","useState","title","annotations","tempResult","setTempResult","tooltipStyle","setTooltipStyle","tooltipContent","setTooltipContent","handleEnterEvidence","e","trope","key","value","current","int_value","parseInt","newAnnotations","newEvidences","evidences","index","indexOf","str","isNaN","parseFloat","sentences","length","push","useEffect","id","onClick","preventDefault","target","checkResult","annotation","option","success","msg","checkValidateSaveResult","alert","idx","style","category","sub_category","definition","map","sent","sent_idx","className","tropeOptions","trope_idx","onMouseOver","Doc","visibility","opacity","transition","handleChangeDefinition","onMouseOut","opt","opt_idx","selected_style","backgroundColor","handleChooseTropeOption","Fragment","ref","placeholder","onKeyDown","sent_line_idx","evidence_idx","splice","handleRemoveEvidence","IGNORE_CORPUS","setData","Object","keys","Corpus","reduce","res","cur","console","error","setResult","annoPaperDisplay","setAnnoPaperDisplay","title_idx","includes","tropes","Tropes","completed_style","completed_annotations","newData","handleChooseCorpus","line","type","onChange","fileReader","FileReader","readAsText","files","onload","JSON","parse","content","fileName","contentType","a","json","stringify","blob","Blob","URL","createObjectURL","href","link","document","createElement","download","body","appendChild","click","removeChild","saveResult","newResult","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.700e48f3.chunk.js","sourcesContent":["import React, { useEffect, useState, useRef } from 'react';\nimport Doc from '../Data/tropes3.json';\nimport '../Css/AnnoPaper.css';\n\nconst isNumeric = (str) => {\n    if (typeof str != \"string\") return false // we only process strings!  \n    return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...\n           !isNaN(parseFloat(str)) // ...and ensure strings of whitespace fail\n};\n\nexport default ({ data, result, handleClosePaperFunc, handleSaveResultFunc }) => {\n\n    // console.log(data);\n    // console.log(result);\n    const inputRef = useRef(null);\n    const [ tempResult, setTempResult ] = useState(() => ({\n            title: 'Default',\n            annotations: {}\n    }));\n    const [ tooltipStyle, setTooltipStyle ] = useState({});\n    const [ tooltipContent, setTooltipContent ] = useState(false);\n\n    const handleChooseTropeOption = (e, trope, opt) => {\n\n        let newAnnotations = { ...tempResult.annotations };\n        newAnnotations[trope] = { ...newAnnotations[trope], trope: trope, option: opt, evidences: [] };\n        setTempResult(tempResult => ({\n            ...tempResult,\n            annotations: newAnnotations\n        }));\n    }\n\n    const handleEnterEvidence = (e, trope) => {\n        if (e.key === 'Enter') {\n            let value = inputRef.current.value;\n            let int_value = parseInt(value);\n            let newAnnotations = { ...tempResult.annotations };\n            let newEvidences = newAnnotations[trope].evidences;\n            let index = newEvidences.indexOf(int_value);\n            if (isNumeric(value) && index === -1 && int_value < (data.sentences.length + 1)) {\n                newEvidences.push(int_value);\n                newAnnotations[trope] = { ...newAnnotations[trope], trope: trope, evidences: newEvidences };\n                setTempResult(tempResult => ({\n                    ...tempResult,\n                    annotations: newAnnotations\n                }));\n            }\n            inputRef.current.value = '';\n        }\n    }\n\n    const handleRemoveEvidence = (e, trope, value) => {\n        let newAnnotations = { ...tempResult.annotations };\n        let newEvidences = newAnnotations[trope].evidences;\n        let index = newEvidences.indexOf(value);\n        if (index !== -1) {\n            newEvidences.splice(index, 1);\n            newAnnotations[trope] = { ...newAnnotations[trope], trope: trope, evidences: newEvidences };\n            setTempResult(tempResult => ({\n                ...tempResult,\n                annotations: newAnnotations\n            }));\n        }\n    }\n    \n    const checkValidateSaveResult = () => {\n        for (var trope in tempResult.annotations) {\n            let annotation = tempResult.annotations[trope];\n            if ((annotation.option === 'Match' || annotation.option === 'Similar') \n                && annotation.evidences.length === 0) \n                return {\n                    success: false,\n                    msg: `The evidences of trope \"${trope}\" cannot be empty!`\n                };\n        }\n        return {\n            success: true,\n            msg: ''\n        };\n    }\n\n    const handleChangeDefinition = (e, trope) => {\n        \n        // if (showDefintion && trope === tooltipContent.trope) setShowDefintion(false);\n        // else {\n            if (trope in Doc) {\n                setTooltipStyle({\n                    visibility: 'visible',\n                    opacity: 1,\n                    transition: 'opacity 0.3s'\n                });\n                let { category, sub_category, definition } = Doc[trope];\n                setTooltipContent({\n                    trope: trope,\n                    category: category || '...',\n                    sub_category: sub_category || '...', \n                    definition: definition\n                });\n            }\n            else {\n                setTooltipStyle({});\n            }\n        // }\n    }\n\n    useEffect(() => {\n        setTempResult(result);\n    }, [result])\n\n    return (\n        <div id=\"anno_paper\"\n            onClick={(e) => {\n                e.preventDefault();\n                if (e.target.id === 'anno_paper') {\n                    \n                    let checkResult = checkValidateSaveResult();\n                    if (checkResult.success)  {\n                        handleClosePaperFunc(e);\n                        handleSaveResultFunc(tempResult);\n                    }\n                    else\n                        alert(checkResult.msg);\n                }\n            }}\n        >\n            <div \n                id=\"paper_container\"\n                \n            >\n                <div id=\"paper_container_row1\">\n                    <div id=\"paper_container_row1_title\"><p>{`${data.idx}. ${data.title}`}</p></div>\n                    <div \n                        id=\"paper_container_row1_trope_tooltip\"\n                        style={tooltipStyle}\n                    >\n                        <p id=\"paper_container_row1_trope_tooltip_title\">\n                            {`${tooltipContent.trope}`}\n                        </p>\n                        <p id=\"paper_container_row1_trope_tooltip_subtitle\">\n                            {`[ ${tooltipContent.category} / ${tooltipContent.sub_category} ]`}\n                        </p>\n                        <p id=\"paper_container_row1_trope_tooltip_content\">{tooltipContent.definition}</p>\n                    </div>\n                </div>\n                <div id=\"paper_container_row2\">\n                    <div id=\"paper_container_row2_corpus_content\">\n                        {data.sentences.map((sent, sent_idx) => (\n                            <div \n                                className=\"paper_container_row2_corpus_sentence_box\"\n                                key={sent_idx+1}\n                            >\n                                <div className=\"paper_container_row2_corpus_sentence_index\">{sent_idx+1}</div>\n                                <div className=\"paper_container_row2_corpus_sentence\">{sent}</div>\n                            </div>\n                        ))}\n                    </div>\n                    <div id=\"paper_container_row2_trope_group\">\n                        {data.tropeOptions.map((trope, trope_idx) => (\n                            <div \n                                className=\"paper_container_row2_trope_box\"\n                                key={trope_idx}\n                                \n                            >\n                                <div \n                                    className=\"paper_container_row2_trope_title\"\n                                    // onClick={(e) => handleShowDefinition(e, trope)}\n                                    onMouseOver={(e) => handleChangeDefinition(e, trope)}\n                                    onMouseOut={() => { setTooltipStyle({\n                                        opacity: 0,\n                                        transition: 'opacity 1.0s'\n                                    })}}\n                                >\n                                    {trope}\n                                </div>\n                                <div className=\"paper_container_row2_trope_option_group\">\n                                    {['Match', 'Similar', 'None'].map((opt, opt_idx) => {\n                                        let selected_style = (trope in tempResult.annotations && tempResult.annotations[trope].option === opt)? \n                                            { backgroundColor: ' rgb(151, 151, 126)' }:{};\n                                        return (\n                                            <div \n                                                className=\"paper_container_row2_trope_option\"\n                                                key={opt_idx}\n                                                style={selected_style}\n                                                onClick={(e) => handleChooseTropeOption(e, trope, opt)}\n                                            >\n                                                {opt}\n                                            </div>\n                                        );\n                                    })}\n                                </div>\n                                <div className=\"paper_container_row2_trope_evidence_group\">\n                                    {trope in tempResult.annotations && (tempResult.annotations[trope].option === \"Match\" || tempResult.annotations[trope].option === \"Similar\")\n                                    && (\n                                        <React.Fragment>\n                                            \n                                            <div className=\"paper_container_row2_trope_evidence_input_wrapper\">\n                                                <input \n                                                    ref={inputRef}\n                                                    className=\"paper_container_row2_trope_evidence_input\"\n                                                    placeholder=\"index\"\n                                                    onKeyDown={(e) => handleEnterEvidence(e, trope)}\n                                                />\n                                            </div>\n                                            {tempResult.annotations \n                                            && trope in tempResult.annotations \n                                            && tempResult.annotations[trope].evidences.map((sent_line_idx, evidence_idx) => (\n                                                <div \n                                                    key={evidence_idx}\n                                                    className=\"paper_container_row2_trope_evidence\"\n                                                    onClick={(e) => handleRemoveEvidence(e, trope, sent_line_idx)}\n                                                >\n                                                    {sent_line_idx}\n                                                </div>\n                                            ))}\n                                        </React.Fragment>\n                                    )}\n                                </div>\n                                <div className=\"paper_container_row2_trope_box_line\"></div>\n                            </div>\n                        ))}\n                    </div>\n                </div>\n            </div>\n\n            \n        </div>\n    );\n}","import React, { useState } from 'react';\nimport Corpus from '../Data/plots4amt.json';\nimport Tropes from '../Data/tropes4amt_sampled.json';\nimport AnnoPaper from './AnnoPaper';\nimport '../Css/CorpusList.css';\n\nconst IGNORE_CORPUS = [\n    'MissionImpossibleII',\n    'MarleyAndMe',\n    'DeadSpaceDownfall',\n    'CoolRunnings',\n    'SmallTimeCrooks',\n    'MoonOverMiami',\n    'FuneralInBerlin',\n    'TheChangeling',\n    'MurderParty',\n    'Ararat',\n    'WeWereSoldiers',\n    'ExitWounds',\n    'ItHappenedHere',\n    'TheMusicMan',\n    'SnowCake',\n    'BlackSea',\n    'BlackSnakeMoan',\n    'Anaconda',\n    'TheIncredibleShrinkingMan',\n    'TheGingerdeadMan',\n    'ShadowOfADoubt'\n];\n\n// console.log(Corpus);\n// console.log(Tropes);\n\nexport default () => {\n\n    const [ data, setData ] = useState(() => {\n        return {\n            title: 'Default',\n            idx: 1,\n            sentences: ['xxxxx','xxxxxxx', 'xxxxxxxxxxxx'],\n            tropeOptions: ['oooo','ooooooo','ooo']\n        };\n    });\n    const [ result, setResult ] = useState(() => Object.keys(Corpus).reduce((res, cur) => {\n        if (cur in res) console.error('Same key error occurred in Corpus! [' + cur + ']');\n        else res[cur] = { \n                title: cur, \n                annotations: {}\n                // annotations:  Tropes[cur].reduce((ta, tr) => {\n                //     if (tr in ta) console.error('Same key error occurred in Tropes! [' + tr + ']');\n                //     else ta[tr] = { trope: tr, option: '', evidence: [] };\n                //     return ta;\n                // }, {})\n            };\n        return res;\n    }, {}));\n    const [ annoPaperDisplay, setAnnoPaperDisplay ] = useState(false);\n\n    const handleChooseCorpus = (e, newData) => {\n        e.preventDefault();\n        setData(newData);\n        setAnnoPaperDisplay(true);\n    }\n\n    const handleClosePaper = (e) => {\n        setAnnoPaperDisplay(false);\n    }\n\n    const handleSaveResult = (saveResult) => {\n        let { title, annotations } = saveResult;\n        let newResult = { ...result };\n        newResult[title].annotations = {\n            ...newResult[title].annotations,\n            ...annotations\n        };\n        // console.log(saveResult);\n        // console.log(newResult);\n        setResult(newResult);\n    }\n\n    const handleSave2File = () => {\n\n        async function download(content, fileName, contentType) {\n            \n            const json = JSON.stringify(content);\n            const blob = new Blob([json],{type: contentType});\n            const href = await URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = href;\n            link.download = fileName + \".json\";\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n        }\n        download(result, 'test', 'application/json');\n    }\n\n    const handleLoadFromFile = (e) => {\n\n        const fileReader = new FileReader();\n        fileReader.readAsText(e.target.files[0], \"UTF-8\");\n        fileReader.onload = e => {\n            setResult(JSON.parse(e.target.result));\n        };\n    }\n\n    return (\n        <React.Fragment>\n            <div id=\"corpus_list\">\n                <div id=\"corpus_list_title\">Trope Annotation</div>\n                <div id=\"corpus_list_content\">\n                    {Object.keys(Corpus).map((title, title_idx) => {\n                        if (IGNORE_CORPUS.includes(title)) return null;\n                        let tropes = Tropes[title];\n                        let completed_style = {};\n                        let completed_annotations = Object.keys(result[title].annotations);\n                        if (completed_annotations.length === tropes.length) \n                            completed_style = { backgroundColor: 'green' };\n                        return (\n                            <div \n                                className=\"corpus_list_item\" \n                                key={title_idx+1}\n                                style={completed_style}\n                                onClick={(e) => handleChooseCorpus(e, {\n                                    title: title,\n                                    idx: title_idx + 1,\n                                    sentences: Object.keys(Corpus[title]).map((line) => Corpus[title][line]),\n                                    tropeOptions: Tropes[title]\n                                })}\n                            >\n                                <span className=\"corpus_list_item_title\"><p>{`${title_idx+1}. ${title}`}</p></span>\n                                <span className=\"corpus_list_item_status\">\n                                    {completed_annotations.length}/{tropes.length}\n                                </span>\n                            </div>\n                        );\n                    })}\n                </div>\n                <div id=\"btn_group\">\n                    <div id=\"load_btn\">\n                        <input type=\"file\" onChange={handleLoadFromFile} />\n                    </div>\n                    <div id=\"save_btn\" onClick={handleSave2File}><p>Save</p></div>\n                </div>\n            </div>\n            {annoPaperDisplay \n                && <AnnoPaper \n                    data={data}\n                    result={result[data.title]}\n                    handleClosePaperFunc={handleClosePaper}\n                    handleSaveResultFunc={handleSaveResult}\n                />\n            }\n            \n        </React.Fragment>\n    );\n}","import React from 'react';\nimport './App.css';\nimport CorpusList from './Component/CorpusList';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <CorpusList />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}